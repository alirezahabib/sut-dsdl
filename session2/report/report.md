# گزارش آزمایش ۲ - آزمایشگاه طراحی سیستم‌های دیجیتال
> Alireza Habibzadeh `99109393`

## پیاده‌سازی شمارنده
برای پیاده‌سازی شمارنده از فلیپ‌فلاپ‌های T به صورت سنکرون استفاده می‌کنیم. برای تعیین T این فلیپ‌فلاپ‌ها کافی است از `AND` خروجی‌های فلیپ‌فلاپ‌های قبلی در نمایش بیتی استفاده کنیم. برای وقتی که شمارش رو به پایین است (`U = 0`)، باید `NOT` خروجی‌ها را در محاسبات شرکت دهیم. برای این کار خروجی‌ها را با (وارونِ)
`XOR`
U
می‌کنیم.
تصویری از مدار نهایی شمارنده در انتهای فایل آمده است.

## پیاده‌سازی مدار اصلی
حال باید سیگنال‌های مورد نظر را در مدار شماتیک اصلی پیاده کنیم. با توجه به جدول زیر پایه‌های شمارنده را تعیین می‌کنیم.

| IN | OUT | U | Enable |
|----|-----|---|--------|
| 0  | 0   | 0 | 0      |
| 0  | 1   | 0 | 1      |
| 1  | 0   | 1 | 1      |
| 1  | 1   | 0 | 0      |

پس
`'U = IN . OUT`
و
`Enable = IN ⊕ OUT`

حال که شمارنده به درستی تعداد افراد حاضر در اتاق را ذخیره می‌کند، سیگنال‌های خروجی را باید با توجه به آن تعیین کنیم. سیگنال `close` ساده است. باید صفر بودن تعداد افراد را چک کنیم.

> <img src="pic1.png" width="400">
>
> close signal

برای سیگنال `open1` باید شروط مورد نظر سوال ارضا شده باشد. `T` فعال باشد، دکمه فشار داده شده باشد و اتاق پر نباشد.

> <img src="pic2.png" width="550">
>
> open signal (not latched)

اما سیگنالی که اینجا تولید کردیم latch شده نیست. برای حفظ آن تا زمانی که کسی وارد اتاق نشده (مطابق خواسته‌ی سوال) از یک D-flipflop استفاده می‌کنیم.

> <img src="pic3.png" width="450">
>
> open signal (latched) (CLR = in1)

در انتهای فایل طراحی شماتیک کلی آمده است.

## تست
برای تست ابتدا به یک کلاک برای شمارنده نیاز داریم. کد زیر رجیستری به نام `clk` را هر ‍`5ns` یکبار وارون می‌کند.
نتیجه کلاکی با دوره تناوب `10ns` است.

```verilog
always #5 clk = ~clk;
```

حال چندین تست مختلف از حالاتی که هیچ‌کس در اتاق نیست، اتاق خالی و پر می‌شود، اتاق پر است و درخواست ورود داریم و... انجام می‌دهیم. برای راحتی این تست‌ها را پشت هم قرار می‌دهیم تا با یک بار شبیه‌سازی پشت هم انجام شوند. در نهایت کد اصلی که در فایل تستری که خود نرم‌افزار تولید می‌کند (و initializationها را انجام می‌دهد) قرار می‌دهیم.

```verilog
always #5 clk = ~clk;
	
initial begin
	T = 0;
	Ent = 0;
	out1 = 0;
	in1 = 0;
	clk = 0;
	#50
	
	Ent = 1; #20 Ent = 0; #20
	in1 = 1; #10 in1 = 0; #10
	
	T = 1;
	Ent = 1; #20 Ent = 0; #20;
	in1 = 1; #10 in1 = 0; #10;
	
	out1 = 1; #10 out1 = 0; #10;
	
	out1 = 1; #10 out1 = 0; #10;
	
	Ent = 1; #20 Ent = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	#10 in1 = 1; #10 in1 = 0;
	
	#20 Ent = 1; #20 Ent = 0;
	
end
```

## شبیه‌سازی
پس از اجرای شبیه‌ساز پنجره‌ی نهایی به صورت زیر است.

> <img src="pic4.png" width="1080">
>
> simulation window

در حین کار برای debugging متغییرهای مدار را به صورت خروجی اضافه کردم که همگی در انتها پسوند `debug_` دارند. برای فهم بهتر خروجی‌ها این متغیرها را در انتها حذف نکردم. هر چند جزو خواسته‌ی سوال نیستند و خروجی‌های اصلی مدار `open1` و `close` است. در انتهای فایل خروجی کامل موج مدار آمده است.
